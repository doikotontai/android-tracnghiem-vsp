<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<!-- Giữ user-scalable=no để ta tự xử lý zoom bằng JS mượt hơn, tránh xung đột với trình duyệt -->
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<title>Learning Content Galaxy - VEO3</title>
<script src="https://cdn.tailwindcss.com?plugins=forms,typography,container-queries"></script>
<link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&amp;display=swap" rel="stylesheet"/>
<script>
    tailwind.config = {
        darkMode: "class",
        theme: {
            extend: {
                colors: {
                    holo: {
                        bg: "#050810",
                        surface: "rgba(10, 20, 35, 0.9)", 
                        border: "rgba(100, 220, 255, 0.3)",
                        text: "#d0e0ff",
                        cyan: "#00f0ff",
                        purple: "#bc13fe",
                        green: "#0aff0a",
                        blue: "#3b82f6"
                    },
                    light: {
                        bg: "#f0f4f9",
                        surface: "rgba(255, 255, 255, 0.9)",
                        border: "rgba(0, 100, 200, 0.2)",
                        text: "#1e293b",
                        accent: "#0284c7"
                    }
                },
                fontFamily: {
                    sans: ["Inter", "sans-serif"],
                    display: "Be Vietnam Pro"
                },
                animation: {
                    'machine-hover': 'machineHover 3s ease-in-out infinite',
                },
                keyframes: {
                    machineHover: {
                        '0%, 100%': { transform: 'translate(-50%, -50%) scale(1)' },
                        '50%': { transform: 'translate(-50%, -52%) scale(1.02)' },
                    }
                }
            }
        }
    };
</script>
<style type="text/tailwindcss">
    :root {
        --bg-primary: #f8fafc;
        --bg-grid: rgba(0, 0, 0, 0.05);
        --bg-gradient-start: rgba(220, 230, 255, 0.6);
        --bg-gradient-end: #ffffff;
        --line-color: rgba(96, 165, 250, 0.4);
        --node-bg: rgba(255, 255, 255, 0.85);
        --node-border: rgba(200, 200, 200, 0.6);
        --node-text: #1e293b;
        --node-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        --main-node-glow: rgba(56, 189, 248, 0.5);
    }

    .dark {
        --bg-primary: #050810;
        --bg-grid: rgba(0, 240, 255, 0.05);
        --bg-gradient-start: rgba(20, 30, 60, 0.4);
        --bg-gradient-end: #050810;
        --line-color: rgba(0, 240, 255, 0.3);
        --node-bg: rgba(15, 25, 45, 0.7);
        --node-border: rgba(0, 240, 255, 0.3);
        --node-text: #d0e0ff;
        --node-shadow: 0 0 15px rgba(0, 240, 255, 0.1);
        --main-node-glow: rgba(0, 220, 255, 0.6);
    }

    body {
        background-color: var(--bg-primary);
        color: var(--node-text);
        overflow: hidden; /* Quan trọng: Ngăn cuộn trang mặc định */
        font-family: 'Inter', sans-serif;
        touch-action: none; /* Quan trọng: Ngăn chặn hành vi zoom/scroll mặc định của trình duyệt để JS xử lý */
        -webkit-tap-highlight-color: transparent;
        transition: background-color 0.5s ease, color 0.5s ease;
    }

    /* --- Background & Container --- */
    .conceptual-map-container {
        position: relative;
        width: 100%;
        height: 100vh;
        overflow: hidden;
        background: 
            radial-gradient(circle at 50% 50%, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 80%),
            linear-gradient(var(--bg-grid) 1px, transparent 1px),
            linear-gradient(90deg, var(--bg-grid) 1px, transparent 1px);
        background-size: 100% 100%, 40px 40px, 40px 40px;
        cursor: grab; /* Con trỏ hình bàn tay để báo hiệu có thể kéo */
    }
    .conceptual-map-container:active {
        cursor: grabbing;
    }

    /* --- Transformer Layer (Lớp chịu tác động Zoom/Pan) --- */
    #galaxy-transformer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform-origin: center center;
        will-change: transform;
        /* Transition chỉ dùng khi reset view, tắt khi drag để mượt */
        transition: transform 0.1s linear; 
    }
    .smooth-reset {
        transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
    }

    /* --- Connecting Lines --- */
    .connecting-line {
        position: absolute;
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--line-color), transparent);
        transform-origin: 0 50%;
        pointer-events: none;
        z-index: 5;
        opacity: 0;
        transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
    }

    /* --- Nodes --- */
    .map-node {
        position: absolute;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 10;
        backdrop-filter: blur(8px);
        transition: opacity 0.3s ease, background 0.5s ease, border-color 0.5s ease, box-shadow 0.5s ease;
        /* Bỏ transition transform ở đây để tránh conflict với zoom */
        -webkit-user-select: none;
        user-select: none;
    }

    .node-hidden {
        opacity: 0;
        pointer-events: none;
        /* Ẩn bằng display none sau khi transition xong để tránh click nhầm */
    }

    /* --- Main Node --- */
    .map-node.type-main {
        width: 180px; 
        height: 180px;
        background: transparent; 
        border: none; 
        box-shadow: none; 
        color: var(--node-text);
        z-index: 10; 
        padding: 0;
        overflow: visible; 
        animation: machine-hover 4s ease-in-out infinite alternate;
    }
    .map-node.type-main::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 60%;
        height: 60%;
        transform: translate(-50%, -50%);
        background: var(--main-node-glow);
        border-radius: 50%;
        filter: blur(40px); 
        opacity: 0.6;
        z-index: -1;
    }
    
    @media (min-width: 768px) {
        .map-node.type-main { width: 300px; height: 300px; }
    }

    /* --- Topic Nodes --- */
    .map-node.type-topic {
        background: var(--node-bg);
        border: 1px solid var(--node-border);
        border-radius: 50px;
        padding: 6px 14px;
        color: var(--node-text);
        font-weight: 600;
        text-transform: uppercase;
        font-size: 0.75rem; 
        min-width: 90px;
        box-shadow: var(--node-shadow);
        white-space: nowrap; 
        z-index: 30; 
    }
    .map-node.type-topic.video-trigger {
        border-color: rgba(255, 68, 68, 0.5); 
        box-shadow: 0 0 15px rgba(255, 68, 68, 0.15);
    }
    .map-node.type-topic.video-trigger .material-symbols-outlined { color: #ef4444; }
    .map-node.type-topic:active, .map-node.type-topic.active-cluster {
        background: rgba(14, 165, 233, 0.15);
        border-color: #0ea5e9;
        /* Scale nhẹ khi active, không ảnh hưởng bố cục */
        transform: translate(-50%, -50%) scale(1.05); 
    }
    .dark .map-node.type-topic:active, .dark .map-node.type-topic.active-cluster {
        background: rgba(0, 240, 255, 0.15);
        border-color: #00f0ff;
    }
    @media (min-width: 768px) {
        .map-node.type-topic { padding: 12px 24px; font-size: 0.9rem; min-width: 140px; }
    }

    /* --- Leaf Nodes --- */
    .map-node.type-image {
        background: var(--node-bg);
        border: 1px solid var(--node-border);
        border-radius: 6px;
        padding: 6px 10px;
        font-size: 0.7rem;
        color: var(--node-text);
        display: flex;
        align-items: center;
        gap: 6px;
        max-width: 160px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        border-left: 3px solid #10b981;
        box-shadow: var(--node-shadow);
    }
    .map-node.type-image .material-symbols-outlined { color: #10b981; font-size: 16px; }
    .map-node.active-node {
        background: #0ea5e9;
        border-color: #fff;
        color: #fff;
        z-index: 50;
    }
    .dark .map-node.active-node { background: rgba(20, 40, 80, 0.95); }

    /* --- Content Panel --- */
    .node-content-panel {
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(20px);
        color: #1e293b;
        z-index: 100; /* Luôn nổi trên cùng, không bị ảnh hưởng bởi zoom transformer */
        position: fixed;
        top: 50%;
        left: 50%;
        width: 90%;
        max-width: 500px;
        max-height: 85vh;
        transform: translate(-50%, -50%) scale(0.9);
        opacity: 0;
        pointer-events: none;
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 20px 60px rgba(0,0,0,0.15), 0 0 0 1px rgba(255,255,255,0.5);
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s ease;
    }
    .dark .node-content-panel {
        background: rgba(12, 18, 32, 0.95);
        border: 1px solid rgba(0, 240, 255, 0.3);
        color: #e0f0ff;
        box-shadow: 0 20px 60px rgba(0,0,0,0.8), 0 0 0 1px rgba(255,255,255,0.1);
    }
    .node-content-panel.panel-visible {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
        pointer-events: auto;
    }

    /* Video & UI Components */
    .aspect-video-container {
        position: relative;
        width: 100%;
        padding-bottom: 56.25%;
        background: #000;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    .aspect-video-container iframe, .aspect-video-container video, .aspect-video-container img {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain;
    }
    .theme-toggle-btn {
        position: fixed; top: 1rem; right: 1rem; z-index: 100;
        background: var(--node-bg); border: 1px solid var(--node-border);
        color: var(--node-text); padding: 8px; border-radius: 50%;
        cursor: pointer; box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        transition: all 0.3s ease; display: flex; align-items: center; justify-content: center;
    }
    .panel-item-light {
        background: rgba(0, 0, 0, 0.03); border: 1px solid rgba(0, 0, 0, 0.05);
    }
    .dark .panel-item-light {
        background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    /* Zoom Controls Hint (Optional) */
    .gesture-hint {
        position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
        background: rgba(0,0,0,0.5); color: white; padding: 6px 12px;
        border-radius: 20px; font-size: 12px; pointer-events: none; opacity: 0;
        transition: opacity 0.5s; z-index: 90;
    }
</style>
</head>
<body class="min-h-screen flex flex-col transition-colors duration-500">

<button class="theme-toggle-btn" onclick="toggleTheme()" aria-label="Toggle Dark Mode">
    <span class="material-symbols-outlined" id="theme-icon">dark_mode</span>
</button>

<div class="fixed top-4 left-4 z-30 pointer-events-none md:hidden">
    <div class="flex items-center space-x-2 bg-white/40 dark:bg-black/40 backdrop-blur rounded-full p-1 pr-3 border border-black/10 dark:border-white/10 pointer-events-auto shadow-sm">
        <div class="w-8 h-8 rounded-full bg-blue-100 dark:bg-holo-cyan/20 flex items-center justify-center text-blue-600 dark:text-holo-cyan">
            <span class="material-symbols-outlined text-lg">science</span>
        </div>
        <span class="text-xs font-bold text-slate-700 dark:text-white tracking-widest">VEO3</span>
    </div>
</div>

<div class="gesture-hint" id="zoom-hint">Kéo để di chuyển • Nhấn đúp để Reset</div>

<div id="panel-overlay" class="fixed inset-0 bg-black/30 dark:bg-black/70 backdrop-blur-[2px] z-50 hidden opacity-0 transition-opacity duration-300" onclick="closePanel()"></div>

<!-- Main Canvas Wrapper -->
<main class="flex-grow w-full relative h-screen overflow-hidden">
    <!-- Event Listener Container -->
    <div class="absolute inset-0 conceptual-map-container" id="learning-galaxy">
        
        <!-- Transformer Layer: This layer will be Panned/Zoomed -->
        <div id="galaxy-transformer">
            
            <!-- Center Core -->
            <div class="map-node type-main" id="main-node">
                <img src="./media_veo3/veo3hinhmay.png" alt="VEO3 Machine" class="w-full h-full object-contain filter drop-shadow-xl dark:drop-shadow-[0_0_20px_rgba(0,240,255,0.4)] transition-all duration-300">
            </div>

            <!-- Topic Nodes -->
            <div class="map-node type-topic video-trigger" data-node-id="core-docs">
                <span class="material-symbols-outlined text-base mr-1 md:mr-2">play_circle</span>
                VIDEO HDSD
            </div>
            <div class="map-node type-topic" data-node-id="visual-assets">
                <span class="material-symbols-outlined text-base mr-1 md:mr-2">perm_media</span>
                Assets
            </div>
            <div class="map-node type-topic" data-node-id="structure-map">
                <span class="material-symbols-outlined text-base mr-1 md:mr-2">hub</span>
                SƠ ĐỒ TỔNG
            </div>
            
        </div>
    </div>

    <!-- DETAILS PANEL -->
    <div class="node-content-panel shadow-2xl" id="content-detail-panel">
        <button class="absolute top-4 right-4 text-slate-400 hover:text-slate-800 dark:text-white/50 dark:hover:text-white p-2 z-10 transition-colors" onclick="closePanel()">
            <span class="material-symbols-outlined">close</span>
        </button>
        <h3 class="font-semibold text-lg mb-2 flex items-center pr-8 text-slate-800 dark:text-white">
            <span class="material-symbols-outlined text-xl mr-2 text-blue-500 dark:text-holo-cyan" id="panel-icon"></span>
            <span id="panel-title">Tiêu đề</span>
        </h3>
        <div class="h-px w-full bg-gradient-to-r from-blue-200 to-transparent dark:from-holo-cyan/50 mb-4"></div>
        <div class="overflow-y-auto max-h-[60vh] pr-1 scrollbar-hide">
            <div class="aspect-video-container mb-4 hidden" id="media-container">
                <div id="youtube-embed"></div>
                <img alt="Content preview" class="hidden" id="panel-image" src=""/>
                <video class="hidden" controls="" id="panel-video" src=""></video>
            </div>
            <div class="hidden flex flex-col gap-2 mb-4" id="list-container"></div>
            <p class="text-sm text-slate-600 dark:text-gray-300 leading-relaxed mb-4" id="panel-description">Mô tả nội dung...</p>
        </div>
        <a class="flex items-center justify-center w-full py-3 bg-blue-600 hover:bg-blue-700 dark:bg-holo-cyan dark:hover:bg-cyan-400 text-white dark:text-black font-bold rounded-lg mt-2 active:scale-95 transition-all shadow-lg hover:shadow-xl" href="#" id="panel-link" target="_blank">
            <span>TRUY CẬP DỮ LIỆU</span>
            <span class="material-symbols-outlined text-lg ml-2">arrow_forward</span>
        </a>
    </div>
</main>

<script>
    // --- Data Configuration ---
    const nodeData = {
        'core-docs': {
            title: 'HƯỚNG DẪN VẬN HÀNH VEO3',
            description: 'Xem video chi tiết quy trình lắp đặt và vận hành hệ thống VEO3.',
            icon: 'play_circle',
            link: 'https://youtu.be/b2TZ0QTYN-I',
            videoType: 'youtube', 
            videoSrc: 'https://www.youtube.com/embed/b2TZ0QTYN-I?autoplay=1', 
            children: [] 
        },
        'visual-assets': {
            title: 'HƯỚNG DẪN VẬN HÀNH VEO3',
            description: 'Danh sách các sơ đồ khối',
            icon: 'perm_media',
            link: '#',
            viewType: 'list', 
            children: [
                { type: 'image', title: '1 – KHỞI ĐỘNG & CHUẨN BỊ', description: 'Phân tích cấu trúc khối 1.', icon: 'settings_power', link: '#', details: 'IMG // 4.6 MB', image: './media_veo3/Khối 1.png' },
                { type: 'image', title: '2 – TẠO SETUP MỚI', description: 'Create Configuration', icon: 'add_circle', link: '#', details: 'IMG // 4.6 MB', image: './media_veo3/Khối 2.png' },
                { type: 'image', title: '3 – KHAI BÁO ĐẦU DÒ/NÊM', description: 'Load Probe/Wedge', icon: 'sensors', link: '#', details: 'IMG // 4.6 MB', image: './media_veo3/Khối 3.png' },
                { type: 'image', title: '4 – THIẾT LẬP SCAN PLAN', description: 'Group Setup', icon: 'qr_code_scanner', link: '#', details: 'IMG // 4.6 MB', image: './media_veo3/Khối 4.png' },
                { type: 'image', title: '5 – TẠO GROUP 2', description: 'Nếu cần thiết', icon: 'layers', link: '#', details: 'IMG // 4.6 MB', image: './media_veo3/Khối 5.png' },
                { type: 'image', title: '6 – HIỆU CHUẨN', description: 'Calibration', icon: 'tune', link: '#', details: 'IMG // 4.6 MB', image: './media_veo3/Khối 6.png' },
                { type: 'image', title: '7 – HOÀN THIỆN THIẾT LẬP', description: 'Final Setup', icon: 'check_circle', link: '#', details: 'IMG // 4.6 MB', image: './media_veo3/Khối 7.png' },
                { type: 'image', title: '8 – QUÉT THỰC TẾ & DỮ LIỆU', description: 'Data Acquisition', icon: 'database', link: '#', details: 'IMG // 4.6 MB', image: './media_veo3/Khối 8.png' },
		]
        },
        'structure-map': {
            title: 'Sơ Đồ Hệ Thống',
            description: 'Sơ đồ tổng quan toàn bộ hệ thống VEO3.',
            icon: 'hub',
            link: '#',
            image: './media_veo3/mindmaptong.png',
            children: []
        }
    };

    // --- State ---
    const state = {
        activeCluster: null,
        activeLeaf: null,
    };

    // --- DOM ---
    const galaxy = document.getElementById('learning-galaxy');
    const transformer = document.getElementById('galaxy-transformer');
    const mainNode = document.getElementById('main-node');
    const contentPanel = document.getElementById('content-detail-panel');
    const overlay = document.getElementById('panel-overlay');
    const mediaContainer = document.getElementById('media-container');
    const listContainer = document.getElementById('list-container');
    const youtubeEmbed = document.getElementById('youtube-embed');
    const themeIcon = document.getElementById('theme-icon');
    
    // Panel Elements
    const pTitle = document.getElementById('panel-title');
    const pDesc = document.getElementById('panel-description');
    const pIcon = document.getElementById('panel-icon');
    const pImg = document.getElementById('panel-image');
    const pVid = document.getElementById('panel-video');
    const pLink = document.getElementById('panel-link');

    // --- Theme Logic ---
    function initTheme() {
        const userPref = localStorage.getItem('theme');
        if (userPref === 'dark') {
            document.documentElement.classList.add('dark');
            themeIcon.textContent = 'light_mode'; 
        } else {
            document.documentElement.classList.remove('dark');
            themeIcon.textContent = 'dark_mode'; 
        }
    }

    function toggleTheme() {
        const html = document.documentElement;
        html.classList.toggle('dark');
        if (html.classList.contains('dark')) {
            localStorage.setItem('theme', 'dark');
            themeIcon.textContent = 'light_mode';
        } else {
            localStorage.setItem('theme', 'light');
            themeIcon.textContent = 'dark_mode';
        }
    }

    // --- Core Logic ---
    function init() {
        initTheme();
        positionNodes();
        // Hint fade out
        setTimeout(() => document.getElementById('zoom-hint').style.opacity = '0.8', 1000);
        setTimeout(() => document.getElementById('zoom-hint').style.opacity = '0', 5000);
    }

    // --- Positioning Logic ---
    // Note: We position relative to center of the TRANSFORMER, which is width/height of screen.
    function positionNodes() {
        // Recalculate based on current screen size, but nodes are absolute in transformer
        const cx = window.innerWidth / 2;
        const cy = window.innerHeight / 2;
        const isMobile = window.innerWidth < 768;
        
        mainNode.style.left = `${cx}px`;
        mainNode.style.top = `${cy}px`;
        mainNode.style.transform = 'translate(-50%, -50%)';

        const topics = document.querySelectorAll('.map-node.type-topic');
        // Mobile radius increased to ensure separation from the image
        const radius = isMobile ? 145 : 280; 
        
        topics.forEach((topic, index) => {
            let angle;
            if (isMobile) {
                const angles = [-Math.PI/2, Math.PI/6, 5*Math.PI/6];
                angle = angles[index % 3];
            } else {
                angle = (index / topics.length) * 2 * Math.PI - Math.PI/2; 
            }

            const x = cx + radius * Math.cos(angle);
            const y = cy + radius * Math.sin(angle);

            topic.style.left = `${x}px`;
            topic.style.top = `${y}px`;
            topic.style.transform = 'translate(-50%, -50%)';
            
            // Re-render lines if active
            if(state.activeCluster) {
                 const parent = document.querySelector(`[data-node-id="${state.activeCluster}"]`);
                 const children = document.querySelectorAll(`[data-parent-node="${state.activeCluster}"]`);
                 if(parent && children.length > 0) {
                     // Simple re-positioning logic for open clusters could go here
                     // But simplest is to just collapse to avoid artifacts on resize
                     collapseCluster(state.activeCluster);
                 }
            }
        });
    }

    // --- Interactions (Pan & Zoom) ---
    let transformState = { x: 0, y: 0, scale: 1 };
    let isDragging = false;
    let startX = 0, startY = 0;
    let lastX = 0, lastY = 0;
    let initialPinchDist = 0;
    let initialScale = 1;
    let isPinching = false;
    let moveThreshold = 0; // Check to distinguish click vs drag

    // Helper: Update CSS
    function updateTransform() {
        transformer.style.transform = `translate(${transformState.x}px, ${transformState.y}px) scale(${transformState.scale})`;
    }

    // Helper: Distance between two fingers
    function getDistance(touches) {
        return Math.hypot(
            touches[0].clientX - touches[1].clientX,
            touches[0].clientY - touches[1].clientY
        );
    }

    // Mouse Events (Desktop)
    galaxy.addEventListener('mousedown', (e) => {
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        lastX = transformState.x;
        lastY = transformState.y;
        moveThreshold = 0;
        transformer.classList.remove('smooth-reset');
        galaxy.style.cursor = 'grabbing';
    });

    window.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        moveThreshold += Math.abs(e.movementX) + Math.abs(e.movementY);
        transformState.x = lastX + dx;
        transformState.y = lastY + dy;
        updateTransform();
    });

    window.addEventListener('mouseup', () => {
        isDragging = false;
        galaxy.style.cursor = 'grab';
    });

    galaxy.addEventListener('wheel', (e) => {
        e.preventDefault();
        const scaleAmount = -e.deltaY * 0.001;
        const newScale = Math.min(Math.max(0.5, transformState.scale + scaleAmount), 3);
        transformState.scale = newScale;
        updateTransform();
    }, { passive: false });

    // Touch Events (Mobile)
    galaxy.addEventListener('touchstart', (e) => {
        transformer.classList.remove('smooth-reset');
        if (e.touches.length === 1) {
            isDragging = true;
            isPinching = false;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
            lastX = transformState.x;
            lastY = transformState.y;
            moveThreshold = 0;
        } else if (e.touches.length === 2) {
            isDragging = false;
            isPinching = true;
            initialPinchDist = getDistance(e.touches);
            initialScale = transformState.scale;
        }
    }, { passive: false });

    galaxy.addEventListener('touchmove', (e) => {
        if (isDragging && e.touches.length === 1) {
            // Pan
            const dx = e.touches[0].clientX - startX;
            const dy = e.touches[0].clientY - startY;
            moveThreshold += Math.abs(dx) + Math.abs(dy); // Rough estimate
            // Limit Pan
            // transformState.x = lastX + dx;
            // transformState.y = lastY + dy;
            // Unbounded pan feels better for infinite canvas, but let's keep it simple
             transformState.x = lastX + dx;
             transformState.y = lastY + dy;
            updateTransform();
        } else if (isPinching && e.touches.length === 2) {
            // Zoom
            e.preventDefault(); // Prevent browser zoom
            const currentDist = getDistance(e.touches);
            const scaleFactor = currentDist / initialPinchDist;
            const newScale = Math.min(Math.max(0.5, initialScale * scaleFactor), 3);
            transformState.scale = newScale;
            updateTransform();
        }
    }, { passive: false });

    galaxy.addEventListener('touchend', (e) => {
        if (e.touches.length === 0) isDragging = false;
        if (e.touches.length < 2) isPinching = false;
    });

    // Double Click/Tap to Reset
    let lastTap = 0;
    galaxy.addEventListener('touchend', (e) => {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        if (tapLength < 300 && tapLength > 0 && moveThreshold < 10) {
            resetView();
            e.preventDefault();
        }
        lastTap = currentTime;
    });
    galaxy.addEventListener('dblclick', () => {
        resetView();
    });

    function resetView() {
        transformer.classList.add('smooth-reset');
        transformState = { x: 0, y: 0, scale: 1 };
        updateTransform();
    }

    // --- Node Click Logic ---
    // Modified to prevent click when dragging
    document.querySelectorAll('.map-node').forEach(node => {
        // Use click for desktop, touchend for mobile logic is handled via click automatically by browser
        // but we need to check moveThreshold
        node.addEventListener('click', (e) => {
            e.stopPropagation();
            
            // If moved significantly, it's a drag, not a click
            // For mouse, we tracked moveThreshold. For touch, we need to check if user was panning.
            // A simple check is: if transform changed significantly during this interaction?
            // Actually, simply checking global isDragging might fail if mouseup happened before click.
            // Better: Check the global 'moveThreshold' variable reset on down.
            if (moveThreshold > 5) return; // 5px tolerance

            const nodeId = node.dataset.nodeId;
            const parentId = node.dataset.parentNode;

            if (nodeId) { // Topic Clicked
                const data = nodeData[nodeId];
                
                if (data && (data.videoType === 'youtube' || data.viewType === 'list' || data.image)) {
                    if (state.activeCluster) collapseCluster(state.activeCluster);
                    showPanel(data);
                    return;
                }

                if (state.activeCluster === nodeId) {
                    collapseCluster(nodeId);
                } else {
                    if (state.activeCluster) collapseCluster(state.activeCluster);
                    expandCluster(nodeId, node);
                }
            } else if (parentId) { // Leaf Clicked
                handleLeafClick(node, parentId);
            } else if (node === mainNode) {
                showPanel({
                    title: 'Hệ Thống VEO3',
                    description: 'Thiết bị kiểm tra siêu âm mảng pha (PAUT) tiên tiến. Nhấp vào các nút xung quanh để xem tài liệu.',
                    icon: 'science',
                    link: '#',
                    image: './media_veo3/veo3hinhmay.png'
                });
            }
        });
        
        // Prevent drag propagation from node to galaxy
        node.addEventListener('touchstart', (e) => {
             // Allow event to bubble so we can pan even if starting on a node?
             // Usually better to ALLOW panning even if touching a node, 
             // but interpret tap as click.
             // So do nothing here.
        }, {passive: true});
    });

    // --- Cluster Logic ---
    function expandCluster(clusterId, parentNode) {
        state.activeCluster = clusterId;
        parentNode.classList.add('active-cluster');
        document.querySelectorAll(`.line-${clusterId}`).forEach(l => l.remove());

        const children = document.querySelectorAll(`[data-parent-node="${clusterId}"]`);
        // Coordinates are relative to the transformer now
        const cx = parseFloat(parentNode.style.left);
        const cy = parseFloat(parentNode.style.top);
        const isMobile = window.innerWidth < 768;
        
        const radius = isMobile ? 110 : 180;
        
        children.forEach((child, index) => {
            child.classList.remove('hidden', 'node-hidden');
            let angle;
            if (isMobile) {
                const isTop = cy < window.innerHeight / 2;
                const baseAngle = isTop ? Math.PI/2 : -Math.PI/2;
                const spread = Math.PI * 0.7; 
                const start = baseAngle - spread/2;
                const step = spread / (children.length - 1 || 1);
                angle = children.length === 1 ? baseAngle : start + (index * step);
            } else {
                angle = (index / children.length) * 2 * Math.PI;
            }

            const tx = cx + radius * Math.cos(angle);
            const ty = cy + radius * Math.sin(angle);

            child.style.left = `${tx}px`;
            child.style.top = `${ty}px`;
            child.style.transform = 'translate(-50%, -50%) scale(1)';

            setTimeout(() => createLine(parentNode, child, `line-${clusterId}`), 300);
        });
    }

    function collapseCluster(clusterId) {
        const parentNode = document.querySelector(`[data-node-id="${clusterId}"]`);
        if(parentNode) parentNode.classList.remove('active-cluster');
        const children = document.querySelectorAll(`[data-parent-node="${clusterId}"]`);
        // Safety check if node exists
        if (!parentNode) return;

        const cx = parseFloat(parentNode.style.left);
        const cy = parseFloat(parentNode.style.top);

        document.querySelectorAll(`.line-${clusterId}`).forEach(l => l.remove());
        children.forEach(child => {
            child.style.left = `${cx}px`;
            child.style.top = `${cy}px`;
            child.classList.add('node-hidden');
            setTimeout(() => child.classList.add('hidden'), 400);
        });
        state.activeCluster = null;
        closePanel();
    }

    function handleLeafClick(node, parentId) {
        if (state.activeLeaf) state.activeLeaf.classList.remove('active-node');
        state.activeLeaf = node;
        node.classList.add('active-node');
        const text = node.textContent.trim();
        const data = nodeData[parentId].children.find(c => text.includes(c.title));
        if(data) showPanel(data);
    }

    function showPanel(data) {
        youtubeEmbed.innerHTML = '';
        pVid.pause();

        pTitle.textContent = data.title;
        pDesc.textContent = data.description;
        pIcon.textContent = data.icon;
        pLink.href = data.link;

        mediaContainer.classList.add('hidden');
        listContainer.classList.add('hidden');
        pImg.classList.add('hidden');
        pVid.classList.add('hidden');
        youtubeEmbed.classList.add('hidden');
        
        listContainer.innerHTML = '';

        if (data.viewType === 'list') {
            listContainer.classList.remove('hidden');
            if (data.children && data.children.length > 0) {
                data.children.forEach(child => {
                    const item = document.createElement('div');
                    item.className = 'panel-item-light flex items-center p-3 rounded-lg cursor-pointer transition-colors group';
                    item.innerHTML = `
                        <div class="w-10 h-10 rounded bg-blue-100 dark:bg-holo-blue/20 flex items-center justify-center mr-3 border border-blue-200 dark:border-holo-blue/30">
                            <span class="material-symbols-outlined text-blue-600 dark:text-holo-blue">${child.icon || 'image'}</span>
                        </div>
                        <div class="flex-grow">
                            <div class="font-medium text-sm text-slate-800 dark:text-white group-hover:text-blue-600 dark:group-hover:text-holo-cyan transition-colors">${child.title}</div>
                            <div class="text-xs text-slate-500 dark:text-gray-400">${child.details || 'Chi tiết'}</div>
                        </div>
                        <span class="material-symbols-outlined text-slate-300 dark:text-white/20 group-hover:text-blue-500 dark:group-hover:text-white transition-colors text-sm">arrow_forward_ios</span>
                    `;
                    item.onclick = () => showPanel(child);
                    listContainer.appendChild(item);
                });
            } else {
                 listContainer.innerHTML = '<p class="text-slate-400 dark:text-gray-500 text-sm text-center py-4">Chưa có dữ liệu.</p>';
            }
        } else if (data.videoType === 'youtube') {
            mediaContainer.classList.remove('hidden');
            youtubeEmbed.classList.remove('hidden');
            youtubeEmbed.innerHTML = `<iframe id="ytplayer" type="text/html" width="100%" height="100%" src="${data.videoSrc}" frameborder="0" allowfullscreen></iframe>`;
        } else if (data.image) {
            mediaContainer.classList.remove('hidden');
            pImg.src = data.image;
            pImg.classList.remove('hidden');
        } else if (data.video) {
            mediaContainer.classList.remove('hidden');
            pVid.src = data.video;
            pVid.classList.remove('hidden');
        }

        contentPanel.classList.add('panel-visible');
        overlay.classList.remove('hidden');
        setTimeout(() => overlay.classList.remove('opacity-0'), 10);
    }

    function closePanel() {
        contentPanel.classList.remove('panel-visible');
        overlay.classList.add('opacity-0');
        setTimeout(() => overlay.classList.add('hidden'), 300);

        setTimeout(() => {
            youtubeEmbed.innerHTML = '';
            pVid.pause();
        }, 300);

        if (state.activeLeaf) {
            state.activeLeaf.classList.remove('active-node');
            state.activeLeaf = null;
        }
    }

    // --- Utils ---
    function createLine(el1, el2, cls) {
        const x1 = parseFloat(el1.style.left);
        const y1 = parseFloat(el1.style.top);
        const x2 = parseFloat(el2.style.left);
        const y2 = parseFloat(el2.style.top);
        const dist = Math.hypot(x2 - x1, y2 - y1);
        const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

        const line = document.createElement('div');
        line.className = `connecting-line ${cls}`;
        line.style.width = `0px`;
        line.style.left = `${x1}px`;
        line.style.top = `${y1}px`;
        line.style.transform = `rotate(${angle}deg)`;
        
        // Append to TRANSFORMER, not Galaxy container
        transformer.appendChild(line);
        
        requestAnimationFrame(() => {
            line.style.width = `${dist}px`;
            line.style.opacity = 1;
        });
    }

    init();
    
    // Add resize listener to re-center main layout if needed (optional)
    window.addEventListener('resize', () => {
         // Only reposition if we haven't panned significantly? 
         // For now, always reposition base layout, user can pan back.
         positionNodes();
    });
</script>
</body>
</html>
